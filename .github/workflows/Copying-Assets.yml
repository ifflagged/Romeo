name: Mirror Release Assets

on:
  schedule:
    - cron: '0,30 * * * *'
  workflow_dispatch:

jobs:
  Downloading_Assets:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    services:
      docker:
        image: xream/script-hub:latest
        ports:
          - 9100:9100
          - 9101:9101
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Git
        run: |
          git config --global user.name "${GITHUB_ACTOR}"
          git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"

      - name: Set repository lists
        run: |
          REPOS=(
            "NSRingo/WeatherKit"
            "NSRingo/GeoServices"
            "NSRingo/Siri"
            "NSRingo/TV"
            "NSRingo/News"
            "NSRingo/Testflight"
            "BiliUniverse/Enhanced"
            "BiliUniverse/Global"
            "BiliUniverse/Redirect"
            "BiliUniverse/ADBlock"
            "BiliUniverse/Roaming"
            "DualSubs/Universal"
            "DualSubs/YouTube"
            "DualSubs/Spotify"
            "DualSubs/Netflix"
            "DualSubs/AddOn"
            "VirgilClyne/GetSomeFries"
          )
          echo "REPOS<<EOF" >> $GITHUB_ENV
          printf "%s\n" "${REPOS[@]}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y curl jq netcat-openbsd

      - name: Wait for Docker services to be ready
        run: |
          echo "Waiting for Docker services to be ready..."
          for i in {1..10}; do
            nc -z localhost 9100 && nc -z localhost 9101 && break
            sleep 10
          done

      - name: Download assets from releases
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ASSETS_CHANGED=false
          UPDATED_FILES=()
          SGMODULE_URLS=()
          PLUGIN_URLS=()

          while IFS= read -r REPO; do
            echo "Processing repository: $REPO"

            if [[ "$REPO" == "VirgilClyne/GetSomeFries" ]]; then
              # 获取 sgmodule 文件和 plugin 文件夹内容
              SGMODULE_FILES=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/$REPO/contents/sgmodule")
              PLUGIN_FILES=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/$REPO/contents/plugin")

              # 处理 sgmodule 文件夹中的文件
              for ASSET in $(echo "$SGMODULE_FILES" | jq -r '.[] | select(.type=="file") | .download_url'); do
                echo "Found sgmodule file: $ASSET"
                SGMODULE_URLS+=("$ASSET")
              done

              if [ ${#SGMODULE_URLS[@]} -gt 0 ]; then
                echo "Saving sgmodule URLs to No_link_provided_for_srmodule.txt"
                printf "%s\n" "${SGMODULE_URLS[@]}" > No_link_provided_for_srmodule.txt
              fi

              # 保存 sgmodule 文件
              for URL in "${SGMODULE_URLS[@]}"; do
                FILENAME=$(basename "$URL")
                OUTPUT_DIR="./Modules/Surge/VirgilClyne"
                mkdir -p "$OUTPUT_DIR"
                OUTPUT_FILE="$OUTPUT_DIR/$FILENAME"

                echo "Downloading sgmodule file: $FILENAME"
                curl -L -H "Authorization: token $GITHUB_TOKEN" -o "$OUTPUT_FILE.tmp" "$URL"

                if [ -f "$OUTPUT_FILE.tmp" ]; then
                  mv "$OUTPUT_FILE.tmp" "$OUTPUT_FILE"
                  UPDATED_FILES+=("$FILENAME")
                  ASSETS_CHANGED=true
                else
                  echo "Failed to download $FILENAME"
                fi
              done

              # 处理 plugin 文件夹中的文件（改后缀为 .lpx）
              for ASSET in $(echo "$PLUGIN_FILES" | jq -r '.[] | select(.type=="file") | .download_url'); do
                echo "Found plugin file: $ASSET"
                PLUGIN_URLS+=("$ASSET")
              done

              for URL in "${PLUGIN_URLS[@]}"; do
                FILENAME=$(basename "$URL")
                FILENAME_LPX="${FILENAME%.plugin}.lpx"
                OUTPUT_DIR="./Modules/Loon/VirgilClyne"
                mkdir -p "$OUTPUT_DIR"
                OUTPUT_FILE="$OUTPUT_DIR/$FILENAME_LPX"

                echo "Downloading plugin file as Loon .lpx: $FILENAME_LPX"
                curl -L -H "Authorization: token $GITHUB_TOKEN" -o "$OUTPUT_FILE.tmp" "$URL"

                if [ -f "$OUTPUT_FILE.tmp" ]; then
                  mv "$OUTPUT_FILE.tmp" "$OUTPUT_FILE"
                  UPDATED_FILES+=("$FILENAME_LPX")
                  ASSETS_CHANGED=true
                else
                  echo "Failed to download $FILENAME_LPX"
                fi
              done

            else
              # 获取每个仓库的最新版本发布信息
              RELEASE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/$REPO/releases/latest")
              if [ -z "$RELEASE" ] || [ "$RELEASE" == "null" ] || [ "$(echo "$RELEASE" | jq -r '.message')" = "Not Found" ]; then
                echo "Release not found for $REPO, skipping."
                continue
              fi

              ASSETS=$(echo "$RELEASE" | jq -c '.assets[]')
              while IFS= read -r ASSET; do
                ASSET_NAME=$(echo "$ASSET" | jq -r '.name')
                ASSET_URL=$(echo "$ASSET" | jq -r '.url')
                ASSET_Surge_URL=$(echo "$ASSET" | jq -r '.browser_download_url')

                EXTENSION="${ASSET_NAME##*.}"

                # 判断保存目录和类型
                if [[ "$REPO" == "NSRingo"* ]]; then
                  if [ "$EXTENSION" = "sgmodule" ]; then
                    OUTPUT_DIR="./Modules/Surge/NSRingo"
                    CORRESPONDING_SRMODULE=$(echo "$RELEASE" | jq -r --arg name "$ASSET_NAME" \
                      '.assets[] | select(.name == ($name | sub(".sgmodule"; ".srmodule"))) | .browser_download_url')
                    if [ -z "$CORRESPONDING_SRMODULE" ]; then
                      SGMODULE_2_URLS+=("$ASSET_Surge_URL")
                    fi
                  elif [ "$EXTENSION" = "plugin" ]; then
                    OUTPUT_DIR="./Modules/Loon/NSRingo"
                    ASSET_NAME="${ASSET_NAME%.plugin}.lpx"   # 改后缀
                  elif [ "$EXTENSION" = "srmodule" ]; then
                    OUTPUT_DIR="./Modules/Shadowrocket/NSRingo"
                  else
                    continue
                  fi
                elif [[ "$REPO" == "BiliUniverse"* ]]; then
                  if [ "$EXTENSION" = "sgmodule" ]; then
                    OUTPUT_DIR="./Modules/Surge/BiliUniverse"
                    CORRESPONDING_SRMODULE=$(echo "$RELEASE" | jq -r --arg name "$ASSET_NAME" \
                      '.assets[] | select(.name == ($name | sub(".sgmodule"; ".srmodule"))) | .browser_download_url')
                    if [ -z "$CORRESPONDING_SRMODULE" ]; then
                      SGMODULE_2_URLS+=("$ASSET_Surge_URL")
                    fi
                  elif [ "$EXTENSION" = "plugin" ]; then
                    OUTPUT_DIR="./Modules/Loon/BiliUniverse"
                    ASSET_NAME="${ASSET_NAME%.plugin}.lpx"
                  elif [ "$EXTENSION" = "srmodule" ]; then
                    OUTPUT_DIR="./Modules/Shadowrocket/BiliUniverse"
                  else
                    continue
                  fi
                elif [[ "$REPO" == "DualSubs"* ]]; then
                  if [ "$EXTENSION" = "sgmodule" ]; then
                    OUTPUT_DIR="./Modules/Surge/DualSubs"
                    CORRESPONDING_SRMODULE=$(echo "$RELEASE" | jq -r --arg name "$ASSET_NAME" \
                      '.assets[] | select(.name == ($name | sub(".sgmodule"; ".srmodule"))) | .browser_download_url')
                    if [ -z "$CORRESPONDING_SRMODULE" ]; then
                      SGMODULE_2_URLS+=("$ASSET_Surge_URL")
                    fi
                  elif [ "$EXTENSION" = "plugin" ]; then
                    OUTPUT_DIR="./Modules/Loon/DualSubs"
                    ASSET_NAME="${ASSET_NAME%.plugin}.lpx"
                  elif [ "$EXTENSION" = "srmodule" ]; then
                    OUTPUT_DIR="./Modules/Shadowrocket/DualSubs"
                  else
                    continue
                  fi
                else
                  continue
                fi

                mkdir -p "$OUTPUT_DIR"
                OUTPUT_FILE="$OUTPUT_DIR/$ASSET_NAME"

                echo "Downloading: $ASSET_NAME"
                curl -L -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/octet-stream" "$ASSET_URL" -o "$OUTPUT_FILE.tmp"

                if [ ! -f "$OUTPUT_FILE.tmp" ]; then
                  echo "Failed to download $ASSET_NAME"
                  continue
                fi

                NEW_CHECKSUM=$(sha256sum "$OUTPUT_FILE.tmp" | awk '{ print $1 }')

                if [ -f "$OUTPUT_FILE" ]; then
                  EXISTING_CHECKSUM=$(sha256sum "$OUTPUT_FILE" | awk '{ print $1 }')
                  if [ "$NEW_CHECKSUM" = "$EXISTING_CHECKSUM" ]; then
                    rm "$OUTPUT_FILE.tmp"
                  else
                    mv "$OUTPUT_FILE.tmp" "$OUTPUT_FILE"
                    UPDATED_FILES+=("$ASSET_NAME")
                    ASSETS_CHANGED=true
                  fi
                else
                  mv "$OUTPUT_FILE.tmp" "$OUTPUT_FILE"
                  UPDATED_FILES+=("$ASSET_NAME")
                  ASSETS_CHANGED=true
                fi

              done <<< "$ASSETS"
            fi
          done < <(printf '%s\n' "${REPOS[@]}")

          # 保存 sgmodule URLs
          if [ ${#SGMODULE_URLS[@]} -gt 0 ] || [ ${#SGMODULE_2_URLS[@]} -gt 0 ]; then
            printf "%s\n" "${SGMODULE_URLS[@]}" >> No_link_provided_for_srmodule.txt
            printf "%s\n" "${SGMODULE_2_URLS[@]}" >> No_link_provided_for_srmodule.txt
          fi

          echo "ASSETS_CHANGED=$ASSETS_CHANGED" >> $GITHUB_ENV
          echo "UPDATED_FILES<<EOF" >> $GITHUB_ENV
          printf "%s\n" "${UPDATED_FILES[@]}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Handling unprovided srmodule modules
        run: |
          category="Jacob"
          encoded_category=$(echo "$category" | jq -sRr @uri)
          while read -r module_link; do
            author=$(echo "$module_link" | cut -d'/' -f4)
            filename_noext=$(basename "$module_link" | sed 's/\(.*\)\..*/\1/')
            encoded_filename=$(echo "$filename_noext" | jq -sRr @uri)

            Shadowrocket_url="http://localhost:9100/file/_start_/${module_link}/_end_/${encoded_filename}.sgmodule?type=surge-module&target=shadowrocket-module&category=${encoded_category}&nore=true"

            mkdir -p Modules/Shadowrocket/$author
            curl -A "Surge Mac/2985" -L -o "Modules/Shadowrocket/$author/$filename_noext.srmodule" "$Shadowrocket_url" || echo "Failed to download $filename_noext.srmodule"
          done < No_link_provided_for_srmodule.txt

      - name: Find and replace external JS resources in .sgmodule, .lpx, and .srmodule files
        continue-on-error: true
        run: |
          js_base_url="https://github.com/${GITHUB_REPOSITORY}/raw/main/Modules/JS"
          mkdir -p Modules/JS/NSRingo Modules/JS/BiliUniverse Modules/JS/DualSubs Modules/JS/VirgilClyne

          for sgmodule_file in $(find Modules/Surge/NSRingo Modules/Surge/BiliUniverse Modules/Surge/DualSubs Modules/Surge/VirgilClyne \
                                      -path "*/Beta/*" -prune -o \
                                      -type f -name "*.sgmodule" -print); do
            author=$(dirname "$sgmodule_file" | sed 's|^Modules/Surge/||')
            module_folder=$(basename "$sgmodule_file" .sgmodule)

            js_links=$(grep -v '#' "$sgmodule_file" | grep -oP 'https?://[^ ]+\.(json|js)' || echo "")

            for js_link in $js_links; do
              js_filename=$(basename "$js_link")
              local_js_path="Modules/JS/$author/$module_folder/$js_filename"
              github_js_url="$js_base_url/$author/$module_folder/$js_filename"
              
              mkdir -p "$(dirname "$local_js_path")"
              curl -A "Surge Mac/2985" -L -o "$local_js_path" "$js_link"

              loon_file="Modules/Loon/$author/$module_folder.lpx"
              shadowrocket_file="Modules/Shadowrocket/$author/$module_folder.srmodule"

              [ -f "$loon_file" ] && sed -i "s|$js_link|$github_js_url|g" "$loon_file"
              [ -f "$shadowrocket_file" ] && sed -i "s|$js_link|$github_js_url|g" "$shadowrocket_file"
              sed -i "s|$js_link|$github_js_url|g" "$sgmodule_file"
            done
          done

      - name: Modify sgmodule files after sync
        run: |
          MODIFICATIONS_MADE=false
          for sgmodule_file in $(find Modules/Surge/NSRingo Modules/Surge/BiliUniverse Modules/Surge/DualSubs Modules/Surge/VirgilClyne \
                                      -path "*/Beta/*" -prune -o \
                                      -type f -name "*.sgmodule" -print); do
            sed -i 's/,pre-matching//g' "$sgmodule_file"
            MODIFICATIONS_MADE=true
          done

          if [ "$MODIFICATIONS_MADE" = "true" ]; then
            ASSETS_CHANGED=true
          fi
          echo "ASSETS_CHANGED=$ASSETS_CHANGED" >> $GITHUB_ENV
          echo "MODIFICATIONS_MADE=$MODIFICATIONS_MADE" >> $GITHUB_ENV

      - name: Commit and push changes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          DATE="$(TZ='Asia/Shanghai' date '+%Y-%m-%d %H:%M:%S')"
          git add Modules/*
          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            COMMIT_MESSAGE="Synched assets at $DATE (UTC+8))"
            git stash
            git pull --rebase
            git stash pop
            git add Modules/*
            git commit -m "$COMMIT_MESSAGE"
            git push
          fi
